
Здесь описана архитектура сервера синхронизации.

!!! Сейчас этот файл содержит устаревшие данные !!!

*************
**** Модули:
****
db_interface
	Инициализирует базу данных (путем обращения к определенной реализации).
	Единственная задача - вернуть ссылку на поток, работающий с БД.
db_impl_*
	Реализация работы с БД. В функциях этого модуля работает поток, 
	работающий с базой. Обмен данными с базой проводится путем отсылки 
	сообщений потоку и от него. Этакий "драйвер БД". Заменив его, можно 
	использовать другую БД.
db_impl_mnesia
	Реализация работы с базой Mnesia.

net_interface
	Работа с сетью. В данный момент совершенно не отлажена. 

syncserver
	Логика работы сервера. Пока тоже не продумана. 
	Предполагается, что в функциях этого модуля должны работать потоки, 
	обменивающиеся сообщениями с клиентами (через net_) и данными 
	с базой (через db_).

records.hrl
	Описания структур.

*************************************
**** Формат сообщений работы с базой. 
****
 {Отправитель,{действие,Пользователь,..<параметры>..}}
Поток-отправитель _обязательно_ уведомляется о результате дествия.

Действия:
	set	#запись данных пользователя по ключу
	get	#чтение данных пользователя по ключу
	erase_key #удаление данных пользователя по ключу
	create_user
	delete_user
	list_keys
	get_password
	set_password

Списки параметров для каждого действия пока не определены.

****************************************
**** Описания структур, хранящихся в БД
****
Принцип работы с базой следующий:
(user,key) -> (description,version,data)

Конкретные примеры приведены для Mnesia.
Каждому пользователю соответствует отдельная таблица. В Mnesia это 
по сути словарь. Ключи словаря - предположительно названия плагинов, 
значения - типа db_value.
-record(db_value,{description,version,data}).

В mnesia таблицы могут быть типов set, sorted_set, bag.

*****************************************
**** TODO
****
1. Определиться с логикой работы сервера.
2. Подумать над протоколом клиент-сервер.
2.1 Кодировка команд сервера, возвращаемых сообщений.
3. Реализовать следующие части (хотя бы прототипы):
3.1 Работа с сетью.
3.2 Логика сервера.
3.3 Плагин к LeechCraft, работающий с сервером.
4. Допилить это всё до приемлемого уровня...

*************************
**** Команды сервера
****

(состояние) КОМАНДА параметры

(login) REGISTER username password
	Регистрация пользователя. При успешной регистрации - переход в running, 
	иначе - закрывает соединение.
(login) LOGIN username password
	Авторизация клиента. Переводит поток сервера в состояние running в случае 
	успеха, иначе - закрывает соединение.
(running) LISTKEYS
	Передача списка ключей клиенту.
(running) DELETEKEY key
	Удаление ключа
(running) GETDESCR key
	Описание ключа.
(running) SETDESCR key descr
	Описание ключа.
(running) KEYVERSION key
	Версия значения ключа.
(running) GET key
	Получить значение по ключу.
(running) SET key version value
	Запись значения по ключу.
(running) UNREGISTER
	Удаление пользователя. 
(running) SETPASSWORD password
	Смена пароля/ключа доступа.
(running) DISCONNECT
	Завершение сеанса.

**********************************
**** Маршалинг.
**** 
  Логически сообщение - список списков байт. Физически - список байт. Сообщение 
содержит название команды и список параметров.
  Все длины представлены четырьмя байтами big endian (старший байт сначала).
  Первые 4 байта сообщения - его длина L. Erlang может автоматически 
обрабатывать такой заголовок и принимать пакеты нужной длины. 
См. gen_tcp:recv, inet:set_opts.
  Далее следуют L чисел - длины подсписков. 
  За ними - данные подсписков.

