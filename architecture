
Здесь описана архитектура сервера синхронизации.

*************
**** Модули:
****
db_interface
	Вызовами различных функций из модуля реализации запускает, останавливает базу данных и работает с ней.
db_impl_*
	Реализация работы с БД. Этакий "драйвер БД". Заменив его, можно 
	использовать другую БД.
db_impl_mnesia
	Реализация работы с базой Mnesia.

net_interface
	Работа с сетью. В данный момент совершенно не отлажена. 

syncserver
	Логика работы сервера. Пока тоже не продумана. 
	Предполагается, что в функциях этого модуля должны работать потоки, 
	обменивающиеся сообщениями с клиентами (через net_) и данными 
	с базой (через db_).

*************************************
**** Формат сообщений работы с базой. 
****
используется в db_interface:db_access/1.
 {действие,Пользователь,..<параметры>..}

	Действия:
{list_keys,User}				список ключей (без служебных ключей)
{put,User,Key,Value}			добавить значение
{set_uniq,User,Key,Value}		установить уникальное значение
{get,User,Key}					список значений
{erase_key,User,Key}			удалить все значения ключа
{erase_record,User,Key,Value}	удалить конкретное значение
{create_user,User,Password}		создать пользователя
{delete_user,User}				удалить пользователя
{user_exists,User}				проверить, есть ли пользователь
{list_users}					список пользователей
{get_password,User}				пароль
{set_password,User,Password}	установить пароль
	Возможно (но не рекомендовано) добавление других действий.

****************************************
**** Описания структур, хранящихся в БД
****
Принцип работы с базой следующий:
(user,key) -> value
user, key - строки
value - список байт (общий случай)
value - erlang term (mnesia)

	Каждому пользователю соответствует отдельная таблица. В Mnesia это 
по сути словарь. Ключи словаря - предположительно названия плагинов, 
значения - бинарные данные или erlang_term.
	Записи в базе могут быть разных типов. В случае хранения бинарных данных 
(списка байт) необходимо поле (в значении), по которому можно определить тип 
записи. В случае хранения erlang_term'ов (Mnesia) можно хранить запись в виде 
кортежа {type,field1,...,fieldN}, однако трудно будет передать её по сети.

В mnesia таблицы могут быть типов set, sorted_set, bag. 
Здесь используется bag (одному ключу могут соответствовать несколько
значений).

*************************
**** Команды сервера
****
	Получив команду из сети в виде сообщения, сервер ее обрабатывает и 
отправляет ответное сообщение. См. конечный автомат Мили. Ответное сообщение
в первом подсписке содержит код успеха (строка OK или ERR), и в остальных 
подсписках может содержать данные или сообщение об ошибке.
	В случае успеха сервер присылает сообщение вида
	["OK",data...]
где data - несколько (N>=0) списков с данными. Если сообщение об успехе 
не передаёт данных, сервер пришлёт просто ["OK"].
	Если были ошибки, то присылается сообщение об ошибке в виде 
	["ERR",code,message]
где code - код ошибки (число из четырех байт), message - сообщение об ошибке
(строка). Сообщения об ошибках заданы в Erlang следующими макросами:

-define(err_unknown_command,
	["ERR",[0,0,0,0],"Unknown command"]).
-define(err_user_registered,
	["ERR",[0,0,0,1],"User is registered already"]).
-define(err_user_not_registered,
	["ERR",[0,0,0,2],"User is not registered"]).
-define(err_password,
	["ERR",[0,0,0,3],"Wrong password"]).
-define(err_already_connected,
	["ERR",[0,0,0,4],"Already connected"]).
-define(err_odd_parameters,
	["ERR",[0,0,0,5],"Odd number of filter parameters"]).
-define(err_wrong_delta_id,
	["ERR",[0,0,0,6],"Wrong delta`s Id"]).

	Далее описываются реализованные команды.

(состояние сервера) КОМАНДА параметры

(login) REGISTER username password
	Регистрация пользователя. Закрывает соединение в случае успеха и неуспеха.
(login) LOGIN username password
	Авторизация клиента. Переводит поток сервера в состояние running в случае 
	успеха, иначе - закрывает соединение.
(login) _
	При неизвестной команде сервер закрывает соединение.

(running) LISTKEYS
	Передача списка ключей клиенту.
(running) ERASEKEY key
	Удаление всех записей ключа.
(running) ERASERECORD key value
	Удаление конкретной записи.
(running) GET key [ { offset pattern } ]
	Получить список значений по ключу. Если заданы шаблоны, то сервер выдаёт 
	только те записи, которые удовлетворяют всем шаблонам.
	pattern - шаблон, offset - смещение от начала значения (нумерация с 1).
(running) SELECT key from len [ { offset pattern } ]
	Аналогично GET, но от записей передаются только части от индекса "from" 
	длиной "len".
(running) PUT key version value
	Добавление значения по ключу.
(running) SETUNIQ key version value
	Запись уникального значения по ключу.
(running) UNREGISTER
	Удаление пользователя. 
(running) SETPASSWORD password
	Смена пароля/ключа доступа.
(running) DISCONNECT
	Завершение сеанса.
(running) _
	При неизвестной команде поток остается в running.
	Эти команды обеспечивают только хранение клиентских данных на сервере, для 
синхронизации надо или добавлять команды, или помещать всю логику в клиент.

	Серверные команды синхронизации:
(running) PUTDELTA key id delta [delta2 ... ]
	Добавление дельты или нескольких дельт. Требуется id>maxId. При добавлении
	нескольких дельт они нумеруются последовательно, начиная с номера 'id'.
(running) GETDELTA key startid
	Получение всех дельт с id>startid в порядке возрастания.
(running) MAXDELTA key
	Максимальный id дельт для данного ключа.

**********************************
**** Хранение дельт
****
	Сервер обеспечивает только хранение дельт, работа с ними - на стороне 
клиента.
	Дельта хранится как запись - объединение 3х списков: 
delta_prefix ++ delta_id ++ delta_data
delta_prefix	идентификатор типа, предположительно 8 байт "DELTA\x00\x00\x00".
delta_id		идентификатор записи, предположительно 4 байта.
delta_data		данные дельты.
	Клиент передает отдельно (в разных подсписках) delta_id и delta_data, 
и получает только delta_data или maxId, а не всю запись. Однако есть 
возможность прочитать (или записать) всю запись, воспользовавшись общими 
("низкоуровневыми") командами.
	Идентификаторы дельты - возрастающая последовательность чисел, 
не обязательно непрерывная. Id представляет собой число в BigEndian, так что 
id'ы можно сравнивать в Erlang'е непосредственно как списки байт.

**********************************
**** Маршалинг.
**** 
	Команды сервера и его ответы передаются в виде сообщений, представляющих
собой списки списков байт. Сообщение содержит название команды и список 
параметров, или код ответа (OK/ERR) и данные.
	Все числа представлены четырьмя байтами в big endian (старший байт сначала).
	Схема сообщения:
[  L ] [ N ] [ K1 ] [ K2 ] ... [ KN ] [ S1 ] [ S2 ] ... [ SN ]
|__4__|__4__|__4___|__4__| ... |__4__|__K1__|__K2_| ... |_KN_|
      |___________________ ... ___L________________ ... _____|
	Первые 4 байта сообщения - его длина L. Сетевая библиотека Erlang'a может 
автоматически обрабатывать такой заголовок и принимать пакеты нужной длины. 
См. gen_tcp:recv, inet:set_opts.
	Затем число N - число подсписков.
	Далее следуют N чисел K1..KN - длины подсписков. 
	За ними - данные подсписков S1..SN длинами K1..KN соответственно.

*****************************************
**** TODO
****
1. Допилить плагин к LeechCraft, работающий с сервером.
2. Реализовать дополнительные команды сервера, если нужно.
3. Автоматические тесты для сервера.
4. Скрипты сборки и установки сервера.

