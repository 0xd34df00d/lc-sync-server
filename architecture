
Здесь описана архитектура сервера синхронизации.

*************
**** Модули:
****
db_interface
	Вызовами различных функций из модуля реализации запускает, останавливает базу данных и работает с ней.
db_impl_*
	Реализация работы с БД. Этакий "драйвер БД". Заменив его, можно 
	использовать другую БД.
db_impl_mnesia
	Реализация работы с базой Mnesia.

net_interface
	Работа с сетью. В данный момент совершенно не отлажена. 

syncserver
	Логика работы сервера. Пока тоже не продумана. 
	Предполагается, что в функциях этого модуля должны работать потоки, 
	обменивающиеся сообщениями с клиентами (через net_) и данными 
	с базой (через db_).

*************************************
**** Формат сообщений работы с базой. 
****
используется в db_interface:db_access/1.
 {действие,Пользователь,..<параметры>..}

	Действия:
{list_keys,User}				список ключей (без служебных ключей)
{put,User,Key,Value}			добавить значение
{set_uniq,User,Key,Value}		установить уникальное значение
{get,User,Key}					список значений
{erase_key,User,Key}			удалить все значения ключа
{erase_record,User,Key,Value}	удалить конкретное значение
{create_user,User,Password}		создать пользователя
{delete_user,User}				удалить пользователя
{user_exists,User}				проверить, есть ли пользователь
{list_users}					список пользователей
{get_password,User}				пароль
{set_password,User,Password}	установить пароль
	Возможно (но не рекомендовано) добавление других действий.

****************************************
**** Описания структур, хранящихся в БД
****
Принцип работы с базой следующий:
(user,key) -> value
user, key - строки
value - список байт (общий случай)
value - erlang term (mnesia)

	Каждому пользователю соответствует отдельная таблица. В Mnesia это 
по сути словарь. Ключи словаря - предположительно названия плагинов, 
значения - бинарные данные или erlang_term.
	Записи в базе могут быть разных типов. В случае хранения бинарных данных 
(списка байт) необходимо поле (в значении), по которому можно определить тип 
записи. В случае хранения erlang_term'ов (Mnesia) можно хранить запись в виде 
кортежа {type,field1,...,fieldN}, однако трудно будет передать её по сети.

В mnesia таблицы могут быть типов set, sorted_set, bag. 
Здесь используется bag (одному ключу могут соответствовать несколько
значений).

*************************
**** Команды сервера
****
	Получив команду из сети в виде сообщения, сервер ее обрабатывает и 
отправляет ответное сообщение. См. конечный автомат Мили. Ответное сообщение
в первом подсписке содержит код успеха (строка OK или ERR), и в остальных 
подсписках может содержать данные или сообщение об ошибке.
	Далее описываются реализованные команды.

(состояние сервера) КОМАНДА параметры

(login) REGISTER username password
	Регистрация пользователя. Закрывает соединение в случае успеха и неуспеха.
(login) LOGIN username password
	Авторизация клиента. Переводит поток сервера в состояние running в случае 
	успеха, иначе - закрывает соединение.
(login) _
	При неизвестной команде сервер закрывает соединение.

(running) LISTKEYS
	Передача списка ключей клиенту.
(running) ERASEKEY key
	Удаление всех записей ключа.
(running) ERASERECORD key value
	Удаление конкретной записи.
(running) GET key [ { offset pattern } ]
	Получить список значений по ключу. Если заданы шаблоны, то сервер выдаёт 
	только те записи, которые удовлетворяют всем шаблонам.
	pattern - шаблон, offset - смещение от начала значения (нумерация с 1).	
(running) PUT key version value
	Добавление значения по ключу.
(running) SETUNIQ key version value
	Запись уникального значения по ключу.
(running) UNREGISTER
	Удаление пользователя. 
(running) SETPASSWORD password
	Смена пароля/ключа доступа.
(running) DISCONNECT
	Завершение сеанса.
(running) _
	При неизвестной команде поток остается в running.

	Эти команды обеспечивают только хранение клиентских данных на сервере, для 
синхронизации надо или добавлять команды, или помещать всю логику в клиент.

**********************************
**** Маршалинг.
**** 
	Команды сервера и его ответы передаются в виде сообщений, представляющих
собой списки списков байт. Сообщение содержит название команды и список 
параметров, или код ответа (OK/ERR) и данные.
	Все числа представлены четырьмя байтами в big endian (старший байт сначала).
	Схема сообщения:
[  L ] [ N ] [ K1 ] [ K2 ] ... [ KN ] [ S1 ] [ S2 ] ... [ SN ]
|__4__|__4__|__4___|__4__| ... |__4__|__K1__|__K2_| ... |_KN_|
      |___________________ ... ___L________________ ... _____|
	Первые 4 байта сообщения - его длина L. Сетевая библиотека Erlang'a может 
автоматически обрабатывать такой заголовок и принимать пакеты нужной длины. 
См. gen_tcp:recv, inet:set_opts.
	Затем число N _ число подсписков.
	Далее следуют N чисел K1..KN _ длины подсписков. 
	За ними _ данные подсписков S1..SN длинами K1..KN соответственно.

*****************************************
**** TODO
****
1. Определиться с логикой работы сервера.
1.1 Реализовать дополнительные команды сервера, если нужно.
2. Плагин к LeechCraft, работающий с сервером.
3. Допилить это всё до приемлемого уровня...
4. Скрипты сборки и установки сервера.

